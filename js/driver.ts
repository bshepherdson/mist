import {
  ptr, stw, stl,
  CLS_ARRAY, CLS_CHARACTER, CLS_COMPILED_METHOD, CLS_PROCESS, CLS_WORD_ARRAY,
  CLS_STRING,
  BEHAVIOR_METHODS, CLASS_NAME, CLASS_VAR1, METHOD_NAME, METHOD_CLASS,
  PROCESS_CONTEXT, PROCESS_PROCESS_TABLE, PROCESS_TABLE_NEXT_PRIORITY,
  MA_NIL, MA_TRUE, MA_FALSE, MA_CLASS_DICT,
  METHOD_BYTECODE, METHOD_LITERALS, METHOD_LOCALS, METHOD_ARGC,
  CTX_LOCALS,
  arraySize, classOf, classTable, mkInstance,
  asJSString, fromSmallInteger, toSmallInteger,
  read, readArray, readIV, readWordArray,
  wordArraySize, wrapString, wrapSymbol,
  writeArray, writeIV, writeWordArray,
} from './memory';
import {newContext} from './corelib';
import {insert, lookup, printDict} from './dict';
import {fork, tick} from './process';
import {vm} from './vm';
import * as debug from './debug';

// Driver that consumes the stream of literal arrays generated by the external
// compiler. See DESIGN.md for details.
// These values are received from outside, as a Uint16Array separate from the
// core memory. Values need to be copied inside.

// The interface here is deliberately one word at a time - this makes the input
// flexible, possible to work through a serial link or other stream. There's no
// random access required.
export class WordStream {
  private index = 0;
  constructor(private readonly stream: Uint16Array) {}

  next(): stw {
    return this.stream[this.index++];
  }

  next32(): stl {
    const hi = this.next();
    const lo = this.next();
    return (hi << 16) | lo;
  }

  atEnd(): boolean {
    return this.index >= this.stream.length;
  }
}

const LIT_TYPE_INTEGER = 1;
const LIT_TYPE_CHARACTER = 2;
const LIT_TYPE_STRING = 3;
const LIT_TYPE_SYMBOL = 4;
const LIT_TYPE_ARRAY = 5;
const LIT_TYPE_TRUE = 6;
const LIT_TYPE_FALSE = 7;
const LIT_TYPE_NIL = 8;
const LIT_TYPE_WORD_ARRAY = 9;

const DRIVER_CMD_METHODS = 1;
const DRIVER_CMD_CLASS_METHODS = 2;
const DRIVER_CMD_IMMEDIATE_CODE = 3;

export class Driver {
  constructor(private readonly stream: WordStream) {}

  // Main interface: interprets the next entire command from the stream.
  // Each command is expected to be a literal array whose first value is a
  // number giving the command:
  // 1 = instance-level methods, 2 = class-level methods, 3 = inline code.
  interpret() {
    const array = this.nextValue(); // Array is a Smalltalk pointer array.
    if (classOf(array) !== read(classTable(CLS_ARRAY))) {
      throw new Error('Only arrays are allowed at the top level of input');
    }

    // The array starts with a number giving a command.
    const cmd = fromSmallInteger(readArray(array, 0));
    switch (cmd) {
      case DRIVER_CMD_METHODS:
      case DRIVER_CMD_CLASS_METHODS:
        this.interpretMethods(array, cmd === DRIVER_CMD_CLASS_METHODS);
        break;
      case DRIVER_CMD_IMMEDIATE_CODE:
        // Create a pseudo-method to hold the literals, argc, etc.
        const method = mkInstance(read(classTable(CLS_COMPILED_METHOD)));
        writeIV(method, METHOD_BYTECODE, readArray(array, 1));
        writeIV(method, METHOD_LITERALS, readArray(array, 2));
        writeIV(method, METHOD_LOCALS, toSmallInteger(0));
        writeIV(method, METHOD_ARGC, toSmallInteger(0));

        const bcs = readIV(method, METHOD_BYTECODE);
        const bcLen = wordArraySize(bcs);
        const ctx = newContext(method, MA_NIL, MA_NIL);
        // The context is missing a locals field, so we create a fake one to
        // support any block args or locals. We assume 16 slots suffices.
        if (readIV(ctx, CTX_LOCALS) === MA_NIL) {
          writeIV(ctx, CTX_LOCALS, mkInstance(read(classTable(CLS_ARRAY)), 16));
        }
        const proc = fork(ctx);
        vm.runningProcess = proc;

        while (readIV(proc, PROCESS_CONTEXT) !== MA_NIL) {
          tick();
        }
        break;
      default:
        throw new Error('Unknown driver command');
    }
  }

  // Reads a single next value from the stream, returning a pair of [type, ptr].
  // The type is eg. LIT_TYPE_INTEGER, the ptr is to the Smalltalk value.
  nextValue(): ptr {
    const type = this.stream.next();
    switch (type) {
      case LIT_TYPE_INTEGER:
        const num = this.stream.next32();
        return toSmallInteger(num);

      case LIT_TYPE_CHARACTER:
        const ch = this.stream.next();
        const asciiTable = readIV(read(classTable(CLS_CHARACTER)), CLASS_VAR1);
        return readArray(asciiTable, ch);

      case LIT_TYPE_WORD_ARRAY:
      case LIT_TYPE_STRING:
        // The length comes next, a single word.
        const len = this.stream.next();
        const clsIndex = type === LIT_TYPE_WORD_ARRAY ?
          CLS_WORD_ARRAY : CLS_STRING;
        const str = mkInstance(read(classTable(clsIndex)), len);
        for (let i = 0; i < len; i++) {
          const ch = this.stream.next();
          writeWordArray(str, i, ch);
        }
        return str;

      case LIT_TYPE_SYMBOL:
        // Collect into a platform string, then use wrapSymbol.
        let sym = '';
        const len2 = this.stream.next();
        for (let i = 0; i < len2; i++) {
          const ch = this.stream.next();
          sym += String.fromCharCode(ch);
        }
        return wrapSymbol(sym);

      case LIT_TYPE_ARRAY:
        // Nest into a literal array.
        const elements = this.stream.next();
        const array = mkInstance(read(classTable(CLS_ARRAY)), elements);
        for (let i = 0; i < elements; i++) {
          const value = this.nextValue();
          writeArray(array, i, value);
        }
        return array;

      case LIT_TYPE_NIL:
        return MA_NIL;
      case LIT_TYPE_TRUE:
        return MA_TRUE;
      case LIT_TYPE_FALSE:
        return MA_FALSE;

      default:
        throw new Error('Unknown type while reading literal');
    }
    return MA_NIL; // Can't happen
  }

  interpretMethods(array: ptr, classy: boolean) {
    // The array is a pointer array containing: cmd, class name, methods...
    const className = readArray(array, 1);
    const name = asJSString(className);
    const classDict = read(MA_CLASS_DICT);
    const classNode = lookup(classDict, className);
    //console.log('Adding methods to ' + asJSString(className));
    if (classNode === MA_NIL) {
      throw new Error('Unrecognized class: ' + asJSString(className));
    }

    // If the "classy" flag is true, we're adding things to Foo class.
    // Since that's nameless, the symbol is for the real Class, and it uses a
    // different command number to indicate the metaclass.
    const cls = classy ? classOf(classNode) : classNode;
    let methodDict = readIV(cls, BEHAVIOR_METHODS);

    // Then each method follows. It's an array like:
    // #( selectorSymbol argc locals #( bytecode... ) #( literals ) )
    const len = arraySize(array);
    for (let i = 2; i < len; i++) { // Start from 2 because of cmd and class.
      const method = readArray(array, i);

      const selector = readArray(method, 0);
      //console.log('    #' + asJSString(selector));
      const argc = readArray(method, 1); // Uninterpreted small int
      const locals = readArray(method, 2); // Same
      const bytecode = readArray(method, 3);
      const literals = readArray(method, 4);

      const compiled = mkInstance(read(classTable(CLS_COMPILED_METHOD)));
      writeIV(compiled, METHOD_BYTECODE, bytecode);
      writeIV(compiled, METHOD_LITERALS, literals);
      writeIV(compiled, METHOD_NAME, selector);
      writeIV(compiled, METHOD_LOCALS, locals);
      writeIV(compiled, METHOD_ARGC, argc);
      writeIV(compiled, METHOD_CLASS, cls);

      // And add it to the class's method dictionary.
      insert(methodDict, selector, compiled);
    }
  }
}

type DriverElement = number|['char', stw, string]|string[]|string|
    DriverElement[]|boolean|null;

// Transforms a stream into a Javascript structure that's friendlier to browse
// in the debugger, to help with following the action of the VM Driver.
export class DebugDriver {
  constructor(private readonly stream: WordStream) {}

  allCommands(): DriverElement[] {
    const ret = [];
    while (!this.stream.atEnd()) {
      ret.push(this.nextValue());
    }
    return ret;
  }

  // Reads a single next value from the stream, returning a pair of [type, ptr].
  // The type is eg. LIT_TYPE_INTEGER, the ptr is to the Smalltalk value.
  nextValue(): DriverElement {
    const type = this.stream.next();
    let len;
    switch (type) {
      case LIT_TYPE_INTEGER:
        const num = this.stream.next32();
        return num;

      case LIT_TYPE_CHARACTER:
        const ch = this.stream.next();
        return ['char', ch, String.fromCharCode(ch)];

      case LIT_TYPE_WORD_ARRAY:
        // The length comes next, a single word.
        len = this.stream.next();
        const wa = [];
        for (let i = 0; i < len; i++) {
          wa.push(this.stream.next().toString(16));
        }
        return wa;

      case LIT_TYPE_STRING:
      case LIT_TYPE_SYMBOL:
        // The length comes next, a single word.
        len = this.stream.next();
        let str = '';
        for (let i = 0; i < len; i++) {
          str += String.fromCharCode(this.stream.next());
        }
        return type === LIT_TYPE_SYMBOL ? '#' + str : str;

      case LIT_TYPE_ARRAY:
        // Nest into a literal array.
        const elements = this.stream.next();
        const array = [];
        for (let i = 0; i < elements; i++) {
          array.push(this.nextValue());
        }
        return array;

      case LIT_TYPE_NIL:
        return null;
      case LIT_TYPE_TRUE:
        return true;
      case LIT_TYPE_FALSE:
        return false;

      default:
        new Error('Unknown type while reading literal');
    }
    return null;
  }
}


