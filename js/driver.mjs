import {
  ASCII_TABLE,
  allocRawArray,
  isPointerArray,
  wrapSmallInteger,
  writeAt,
  writeWord,
} from './memory.mjs';

import {lookupNode} from './tree.mjs';

// Driver that consumes the stream of literal arrays generated by the external
// compiler. See DESIGN.md for details.
// These values are received from outside, as a Uint16Array separate from the
// core memory. Values need to be copied inside.

// The interface here is deliberately one word at a time - this makes the input
// flexible, possible to work through a serial link or other stream. There's no
// random access required.
class WordStream {
  constructor(buf) {
    this.stream = buf;
    this.rewound = [];
    this.index = 0;
  }

  next() {
    if (this.rewound.length > 0) {
      return this.rewound.pop();
    }
    return this.stream[this.index++];
  }

  next32() {
    const hi = this.next();
    const lo = this.next();
    return (hi << 16) | lo;
  }

  rewind(word) {
    this.rewound.push(word);
  }
}

const LIT_TYPE_INTEGER = 1;
const LIT_TYPE_CHARACTER = 2;
const LIT_TYPE_STRING = 3;
const LIT_TYPE_SYMBOL = 4;
const LIT_TYPE_ARRAY = 5;
const LIT_TYPE_TRUE = 6;
const LIT_TYPE_FALSE = 7;
const LIT_TYPE_NIL = 8;

const DRIVER_CMD_METHODS = 1;
const DRIVER_CMD_CLASS_METHODS = 2;
const DRIVER_CMD_IMMEDIATE_CODE = 3;

class Driver {
  constructor(stream) {
    this.stream = stream;
  }

  // Main interface: interprets the next entire command from the stream.
  // Each command is expected to be a literal array whose first value is a
  // number giving the command:
  // 1 = instance-level methods, 2 = class-level methods, 3 = inline code.
  interpret() {
    const array = this.nextValue(); // Array is a Smalltalk pointer array.
    if (!isPointerArray(array)) {
      throw new Error('Only arrays are allowed at the top level of input');
    }

    // The array starts with a number giving a command.
    const cmd = readSmallInteger(array + PA_BASE);
    switch (cmd) {
      case DRIVER_CMD_METHODS:
      case DRIVER_CMD_CLASS_METHODS:
        this.interpretMethods(array, cmd === DRIVER_CMD_CLASS_METHODS);
        break;
      case DRIVER_CMD_IMMEDIATE_CODE:
        throw new Error('Unimplemented');
      default:
        throw new Error('Unknown driver command');
    }
  }

  // Reads a single next value from the stream, returning a pair of [type, ptr].
  // The type is eg. LIT_TYPE_INTEGER, the ptr is to the Smalltalk value.
  nextValue() {
    const type = this.stream.next();
    switch (type) {
      case LIT_TYPE_INTEGER:
        const num = this.stream.next32();
        return wrapSmallInteger(num);

      case LIT_TYPE_CHARACTER:
        const ch = this.stream.next();
        return ASCII_TABLE[ch];

      case LIT_TYPE_STRING:
        // The length of the string is the len word - 2 (length and type).
        const str = allocRawArray(len - 2);
        for (let i = 0; i < len - 2; i++) {
          const ch = this.stream.next();
          writeWord(str + RA_BASE + i, ch);
        }
        return str;

      case LIT_TYPE_SYMBOL:
        // Collect into a platform string, then use wrapSymbol.
        const str = '';
        for (let i = 0; i < len - 2; i++) {
          const ch = this.stream.next();
          str += String.fromCharCode(ch);
        }
        return wrapSymbol(str);

      case LIT_TYPE_ARRAY:
        // Nest into a literal array.
        const elements = this.stream.next();
        const array = allocPointerArray(elements, true /* uninitialized */);
        for (let i = 0; i < elements; i++) {
          const value = this.nextValue();
          writeAt(array, PA_BASE + 2*i, value);
        }
        return array;

      case LIT_TYPE_NIL:
        return MA_NIL;
      case LIT_TYPE_TRUE:
        return MA_TRUE;
      case LIT_TYPE_FALSE:
        return MA_FALSE;

      default:
        new Error('Unknown type while reading literal');
    }
  }

  interpretMethods(array, classy) {
    // The array is a pointer array containing: cmd, class, methods...
    const className = readAt(array, PA_BASE + 2);
    const classNode = lookupNode(read(MA_CLASS_DICT), className);
    if (classNode === MA_NIL) throw new Error('Unrecognized class!');
    const baseClass = readAt(classNode, 

    // If the "classy" flag is true, we're adding things to Foo class.
    // Since that's nameless, the symbol is for the real Class, and it uses a
    // different command number. If this is a classy method, follow the 
    const cls = classy ? 

    // Then each method follows. It's an array like:
    // #( selectorSymbol argc locals #( bytecode... ) #( literals ) )
    const len = pointerArrayLength(array);
    for (let i = 2; i < len; i++) { // Start from 2 because of cmd and class.
      const method = readAt(array, PA_BASE + 2 * i);

      const selector = readAt(method, PA_BASE);
      const argc = readAt(method + PA_BASE + 2); // Uninterpreted small int
      const locals = readAt(method + PA_BASE + 4); // Same
      const bytecode = readAt(method, PA_BASE + 6);
      const literals = readAt(method, PA_BASE + 8);

      const compiled = mkInstance(CLS_COMPILED_METHOD);
      writeAt(compiled, METHOD_BYTECODE, bytecode);
      writeAt(compiled, METHOD_LITERALS, literals);
      writeAt(compiled, METHOD_NAME, selector);
      writeAt(compiled, METHOD_LOCALS, locals);
      writeAt(compiled, METHOD_ARGC, argc);
      writeAt(compiled, METHOD_CLASS, cls);

      // And add it to the class's method dictionary.

    }
  }
}


