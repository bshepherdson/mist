import {
  ASCII_TABLE,
  allocRawArray,
  isPointerArray,
  wrapSmallInteger,
  writeAt,
  writeWord,
} from './memory.mjs';

import {lookupNode} from './tree.mjs';

// Driver that consumes the stream of literal arrays generated by the external
// compiler. See DESIGN.md for details.
// These values are received from outside, as a Uint16Array separate from the
// core memory. Values need to be copied inside.

// The interface here is deliberately one word at a time - this makes the input
// flexible, possible to work through a serial link or other stream. There's no
// random access required.
class WordStream {
  constructor(buf) {
    this.stream = buf;
    this.rewound = [];
    this.index = 0;
  }

  next() {
    if (this.rewound.length > 0) {
      return this.rewound.pop();
    }
    return this.stream[this.index++];
  }

  next32() {
    const hi = this.next();
    const lo = this.next();
    return (hi << 16) | lo;
  }

  rewind(word) {
    this.rewound.push(word);
  }
}

const LIT_TYPE_INTEGER = 1;
const LIT_TYPE_CHARACTER = 2;
const LIT_TYPE_STRING = 3;
const LIT_TYPE_SYMBOL = 4;
const LIT_TYPE_ARRAY = 5;
const LIT_TYPE_TRUE = 6;
const LIT_TYPE_FALSE = 7;
const LIT_TYPE_NIL = 8;

const DRIVER_CMD_METHODS = 1;
const DRIVER_CMD_CLASS_METHODS = 2;
const DRIVER_CMD_IMMEDIATE_CODE = 3;

class Driver {
  constructor(stream) {
    this.stream = stream;
  }

  // Main interface: interprets the next entire command from the stream.
  // Each command is expected to be a literal array whose first value is a
  // number giving the command:
  // 1 = instance-level methods, 2 = class-level methods, 3 = inline code.
  interpret() {
    const array = this.nextValue(); // Array is a Smalltalk pointer array.
    if (classOf(array) !== read(classTable(CLS_ARRAY))) {
      throw new Error('Only arrays are allowed at the top level of input');
    }

    // The array starts with a number giving a command.
    const cmd = fromSmallInteger(readArray(array, 0));
    switch (cmd) {
      case DRIVER_CMD_METHODS:
      case DRIVER_CMD_CLASS_METHODS:
        this.interpretMethods(array, cmd === DRIVER_CMD_CLASS_METHODS);
        break;
      case DRIVER_CMD_IMMEDIATE_CODE:
        throw new Error('Unimplemented');
      default:
        throw new Error('Unknown driver command');
    }
  }

  // Reads a single next value from the stream, returning a pair of [type, ptr].
  // The type is eg. LIT_TYPE_INTEGER, the ptr is to the Smalltalk value.
  nextValue() {
    const type = this.stream.next();
    switch (type) {
      case LIT_TYPE_INTEGER:
        const num = this.stream.next32();
        return toSmallInteger(num);

      case LIT_TYPE_CHARACTER:
        const ch = this.stream.next();
        const asciiTable = readIV(read(classTable(CLS_CHARACTER)), CLASS_VAR1);
        return readArray(asciiTable, ch);

      case LIT_TYPE_STRING:
        // The length comes next, a single word.
        const len = this.stream.next();
        const str = mkInstance(read(classTable(CLS_STRING)), len);
        for (let i = 0; i < len; i++) {
          const ch = this.stream.next();
          writeWordArray(str, i, ch);
        }
        return str;

      case LIT_TYPE_SYMBOL:
        // Collect into a platform string, then use wrapSymbol.
        const str = '';
        const len = this.stream.next();
        for (let i = 0; i < len; i++) {
          const ch = this.stream.next();
          str += String.fromCharCode(ch);
        }
        return wrapSymbol(str);

      case LIT_TYPE_ARRAY:
        // Nest into a literal array.
        const elements = this.stream.next();
        const array = mkInstance(read(classTable(CLS_ARRAY)), elements);
        for (let i = 0; i < elements; i++) {
          const value = this.nextValue();
          writeArray(array, i, value);
        }
        return array;

      case LIT_TYPE_NIL:
        return MA_NIL;
      case LIT_TYPE_TRUE:
        return MA_TRUE;
      case LIT_TYPE_FALSE:
        return MA_FALSE;

      default:
        new Error('Unknown type while reading literal');
    }
  }

  interpretMethods(array, classy) {
    // The array is a pointer array containing: cmd, class name, methods...
    const className = readArray(array, 1);
    const classDict = read(MA_CLASS_DICT);
    const classNode = lookup(classDict, className);
    if (classNode === MA_NIL) throw new Error('Unrecognized class!');

    // If the "classy" flag is true, we're adding things to Foo class.
    // Since that's nameless, the symbol is for the real Class, and it uses a
    // different command number. If this is a classy method, f
    const cls = classy ? classNode : classOf(classNode);
    const methodDict = readIV(cls, BEHAVIOR_METHODS);

    // Then each method follows. It's an array like:
    // #( selectorSymbol argc locals #( bytecode... ) #( literals ) )
    const len = arraySize(array);
    for (let i = 2; i < len; i++) { // Start from 2 because of cmd and class.
      const method = readArray(array, i);

      const selector = readArray(method, 0);
      const argc = readArray(method, 1); // Uninterpreted small int
      const locals = readArray(method, 2); // Same
      const bytecode = readArray(method, 3);
      const literals = readArray(method, 4);

      const compiled = mkInstance(read(classTable(CLS_COMPILED_METHOD)));
      writeIV(compiled, METHOD_BYTECODE, bytecode);
      writeIV(compiled, METHOD_LITERALS, literals);
      writeIV(compiled, METHOD_NAME, selector);
      writeIV(compiled, METHOD_LOCALS, locals);
      writeIV(compiled, METHOD_ARGC, argc);
      writeIV(compiled, METHOD_CLASS, cls);

      // And add it to the class's method dictionary.
      insert(methodDict, selector, compiled);
    }
  }
}


